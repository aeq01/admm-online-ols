import numpy as np


class NoisyFunctionMapper:
    """
    Object used to produce semi-real data to train linear models on.
    """

    def __init__(self, x_dimension) -> None:
        self.x_dimension = x_dimension

    def produce_data(self, sample_count, equation) -> (np.array, np.array):
        """
        Produces random input/output data given a function.

        Args:
            sample_count: int
            equation: function mapping x_dimension variables to one output
            x_dimension: number of inputs in function

        Returns:
            A: matrix with sample_count rows and x_dimension columns. Corresponds to input data
            output: vector with sample_count rows. Each element is generated by passing the i_th row of A into the equation and adding noise
        """
        x_coords = []
        x_coords.append(np.ones(sample_count))  # add in the intercept

        # random inputs for the rest of the coordinates
        for _ in range(self.x_dimension):
            x_coords.append(np.random.rand(sample_count))

        A = np.array(x_coords).T
        fv = np.vectorize(equation)

        # ignore the intercept when producing functions
        # add in noise
        output = fv(*A.T[1:]) + np.random.normal(0, 1, sample_count)
        return A, output

    # static method
    def equation_1(val_1, val_2, val_3, val_4) -> np.float32:
        """
        Sample function to pass into produce_data.
        y = 4x_1 - x_2 + 3
        """
        return 4 * val_1 + -1 * val_2 + 3

    # static method
    def equation_2(val_1, val_2, val_3, val_4) -> np.float32:
        """
        Sample function to pass into produce_data
        y = -5x_4 + 11
        """
        return 0 * val_1 + -5 * val_4 + 11

    # static method
    def equation_3(val_1, val_2, val_3, val_4) -> np.float32:
        """
        Sample function to pass into produce_data
        y = x_3 - 3x_4 + 7
        """
        return 1 * val_3 + -3 * val_4 + 7


class DataBlocksManager:
    """
    Stores data blocks incrementally.
    Ex given:
    [A_1, A_2, A_3], where each A_i has n columns and k_i rows.

    Stores:
    blocks: [A_1, A_1 union A_2, A_1 union A_2 union A_3]
    raw_blocks: [A_1, A_2, A_3]
    """

    def __init__(self, given_blocks) -> None:
        assert (
            len(given_blocks) > 0
        ), "Invalid constructor: DataBlocksManager needs at least 1 starting block"
        self.raw_blocks = []
        for block in given_blocks:
            self.raw_blocks.append(np.copy(block))

        self.blocks = [np.copy(self.raw_blocks[0])]
        for i in range(1, len(given_blocks)):
            self.blocks.append(
                np.concatenate(
                    (np.copy(self.blocks[-1]), np.copy(given_blocks[i])), axis=0
                )
            )

    def insert_block(self, new_block) -> None:
        """
        Takes in a new data-block and inserts it into the existing structure

        Args:
            new_block: n samples and k features numpy matrix.

        """
        self.raw_blocks.append(np.copy(new_block))
        self.blocks.append(
            np.concatenate((np.copy(self.blocks[-1]), np.copy(new_block)), axis=0)
        )
